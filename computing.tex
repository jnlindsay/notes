\chapter{Computing}

\section{Graphics}

\subsection{Basics}

\begin{itemize}
	\item Display rate --- number of distinct frames shown per second
	\item Refresh rate --- number of times frames are updated (might be a lot higher than display rate)
\end{itemize}

\section{Algorithms}
\subsection{Dynamic programming}

\begin{shaded}
\textbf{Definition \cite{clrs_algorithms}.} We say that a problem exhibits \textbf{optimal substructure} if optimal solutions to related sub-problems (which may be solved independently) are incorporated into optimal solutions of the problem itself.
\end{shaded}

\begin{shaded}
\textbf{Definition (memoisation (top-down method)) \cite{clrs_algorithms}.} In this approach, we write the procedure recursively in a natural manner, but modified to save the result of each sub-problem (usually in an array or hash table). The procedure now first checks to see whether it has previously solved this sub-problem. If so, it returns the saved value, saving further computation at this level; if not, the procedure computes the value in the usual manner. We say that the recursive procedure has been \textbf{memoised}; it ``remembers'' what results it has computed previously.
\end{shaded}


\section{Cloud computing}

\subsection{Basics}

\subsubsection{Service models}

From Wikipedia \cite{wikipedia_cloud_computing}:
\begin{itemize}
	\item \textbf{SaaS} (application level) --- CRM, email, virtual desktop, communication, games, ...
	\item \textbf{PaaS} (platform level) --- execution runtime, database, web server, development tools, ...
	\item \textbf{IaaS} (infrastructure level) --- virtual machines, servers, storage, load balancers, network, ...
\end{itemize}